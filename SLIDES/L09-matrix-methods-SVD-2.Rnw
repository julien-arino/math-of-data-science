\documentclass[aspectratio=169]{beamer}

% Set lecture number for later use
<<set-lecture-number,echo=FALSE>>=
lecture_number = "09"
@

% Part common to all the lectures
\subtitle{MATH 2740 -- Mathematics of Data Science -- Lecture \Sexpr{lecture_number}}
\author{\texorpdfstring{Julien Arino\newline\url{julien.arino@umanitoba.ca}}{Julien Arino}}
\institute{Department of Mathematics @ University of Manitoba}
\date{Fall 202X}

% Title of the lecture
\title{Matrix methods -- Singular value decomposition}

<<set-options,echo=FALSE,warning=FALSE,message=FALSE>>=
# Source the code common to all lectures
source("common-code.R")
@

<<set-slide-background,echo=FALSE,results='asis'>>=
# Are we plotting for a dark background? Setting is in common-code.R, but
# cat command must run here.
cat(input_setup)
@

\begin{document}

% Cross-reference setup to reference previous lectures
\zexternaldocument{L08-matrix-methods-QR-2-SVD-1}

% Continue theorem numbering from L08 (manual setup - check L08 for current count)
% L08 has several theorems, so we continue from where it left off
\setcounter{theorem}{6}  % Adjust this number based on actual count in L08

% Set up cross-references and counter persistence

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TITLE AND OUTLINE
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\titlepagewithfigure{FIGS-slides-admin/Gemini_Generated_Image_7iz9ft7iz9ft7iz9.jpeg}
\outlinepage{FIGS-slides-admin/Gemini_Generated_Image_iyzqdwiyzqdwiyzq.jpeg}



%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\section{Applications of the SVD -- Least squares}
\newSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_38bqnt38bqnt38bq.jpeg}

\begin{frame}{Applications of the SVD}
Many applications of the SVD, both theoretical and practical..
\vfill
\begin{enumerate}
\item Obtaining a unique solutions to least squares when $A^TA$ singular
\item Image compression
\end{enumerate}
\end{frame}


\begin{frame}{Least squares revisited}
\begin{theorem}
Let $A\in\M_{mn}$, $\bx\in\IR^n$ and $\bb\in\IR^m$. The least squares problem $A\bx=\bb$ has a unique least squares solution $\tilde\bx$ of \emph{minimal length} (closest to the origin) given by
\[
\tilde\bx = A^+\bb
\]
where $A^+$ is the \emph{pseudoinverse} of $A$
\end{theorem}
\end{frame}

\begin{frame}
\begin{definition}[Pseudoinverse]
$A=U\Sigma V^T$ an SVD for $A\in\M_{mn}$, where 
\[
\Sigma = \begin{pmatrix}
D & 0 \\ 0 & 0
\end{pmatrix},
\textrm{ with }
D=\mathsf{diag}(\sigma_1,\ldots,\sigma_r)
\]
($D$ contains the nonzero singular values of $A$ ordered as usual)
\vskip0.5cm
The \textbf{pseudoinverse} (or \textbf{Moore-Penrose inverse}) of $A$ is $A^+\in\M_{nm}$ given by
\[
A^+ = V\Sigma^+ U^T
\]
with
\[
\Sigma^+ =
\begin{pmatrix}
D^{-1} & 0 \\ 0 & 0
\end{pmatrix}\in\M_{nm}
\]
\end{definition}
\end{frame}


%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%
\subsection{Applications of the SVD -- Compressing images}
\newSubSectionSlide{FIGS-slides-admin/Gemini_Generated_Image_6dnw706dnw706dnw.jpeg}


\begin{frame}{Compressing images}
Consider an image (for simplicity, assume in shades of grey). This can be stored in a matrix $A\in\M_{mn}$
\vfill
Take the SVD of $A$. Then the small singular values carry information about the regions with little variation and can perhaps be omitted, whereas the large singular values carry information about more ``dynamic'' regions of the image
\vfill
Suppose $A$  has $r$ nonzero singular values. For $k\leq r$, let
\[
A_k = \sigma_1\bu_1\bv_1^T+\cdots+\sigma_k\bu_k\bv_k^T
\]
\vfill
For $k=r$ we get the usual outer product form \eqref{eq:outer-product-form-SVD}
\end{frame}

\begin{frame}[fragile]
Load the image using \code{bmp::read.bmp}
<<plot-image-svd-original,echo=c(1:3,7),crop=TRUE>>=
my_image = bmp::read.bmp("../CODE/Julien_and_friend_1000x800.bmp")
my_image_g = pixmap::pixmapGrey(my_image)
my_image_g
pixmap::plot(my_image_g)
@
\end{frame}

\maxFrameImage{\Sexpr{knitr::fig_chunk("plot-image-svd-original", "png")}}

\begin{frame}[fragile]\frametitle{Doing the computations ``by hand''}
<<image-compression-svd-compute-MTM>>=
M = my_image_g@grey
MTM = t(M) %*% M
# Ensure matrix is symmetric
MTM = (MTM+t(MTM))/2
ev = eigen(MTM)
@
\vfill
Given the size and nature of the entries, the matrix $M^TM$ is symmetric only to \code{1e-5} precision, so we use a little trick to make it symmetric no matter what: take the average of $M^TM$ and its transpose $MM^T$
\end{frame}


\begin{frame}[fragile]\frametitle{Which version of the algorithm to use?}
Make zero the eigenvalues that are close to zero (\Sexpr{length(which(ev$values<1e-10))} out of \Sexpr{length(ev$values)})
\vfill
<<image-compression-svd-zero-evalues>>=
ev$values = ev$values*(ev$values>1e-10)
@
\vfill
Can we use the algorithm for all eigenvalues being distinct or do we have repeated ones?
\vfill
<<image-compression-svd-check-evalues>>=
any(duplicated(ev$values[ev$values>1e-10]))
@
\vfill
So we can use the standard algorithm
\end{frame}


\begin{frame}[fragile]\frametitle{Computing the SVD}
<<>>=
idx_positive_ev = which(ev$values>1e-10)
sv = sqrt(ev$values[idx_positive_ev])
@
\end{frame}


\begin{frame}[fragile]\frametitle{Computing the SVD}
Then $D=\mathsf{diag}(\sigma_1,\ldots,\sigma_r)$, $V$ is the matrix of normalised eigenvectors in the same order as the $\sigma_i$ and for $i=1,\ldots,r$
$$
\mathbf{u}_i = \frac{1}{\sigma_i}A\mathbf{v}_i
$$
ensuring that $\|\mathbf{u}_i\|=1$
\vfill
<<>>=
D = diag(sv)
V = ev$vectors[idx_positive_ev, idx_positive_ev]
c1 = colSums(V)
for (i in 1:dim(V)[2]) {
    V[,i] = V[,i]/c1[i]
}
@
\end{frame}


\begin{frame}[fragile]\frametitle{Computing the SVD}
Finally, we compute the $\bu_i$'s
\vfill
<<>>=
U = M %*% V %*% diag(1/sv)
r = length(sv)
im = list(u=U, d=sv, v=V)
@
\end{frame}

\begin{frame}[fragile]\frametitle{Using built-in functions}
We can also use the built-in function \code{svd} to compute the SVD of $M$
\vfill
<<>>=
M.svd = svd(M)
@
\vfill
The results are stored in a list with components \code{u}, \code{d} and \code{v}
\end{frame}

\begin{frame}\frametitle{Make function to recreate an image from the SVD}
Given the SVD \code{im} of an image and a number of singular values to keep \code{n}, we can recreate the image using the function \code{compress\_image}
\vfill
We output the new image, but also, the amount of information required to encode this new image, as a percentage of the original image size
\end{frame}

<<compress-image-function>>=
compress_image = function(im, n) {
  if (n > length(im$d)) {
    # Check that we gave a value of n within range, otherwise 
    # just set to the max
    n = length(im$d)
  }
  d_tmp = im$d[1:n]
  u_tmp = im$u[,1:n]
  v_tmp = im$v[,1:n]
  # We store the results in a list (so we can return other information)
    out = list()
    # First, compute the resulting image
    out$img = mat.or.vec(nr = dim(im$u)[1], nc = dim(im$v)[1])
    for (i in 1:n) {
        out$img = out$img + d_tmp[i] * u_tmp[,i] %*% t(v_tmp[,i]) 
    }
    
    
    # Values of the "colours" must be between 0 and 1, so we shift and rescale
    if (min(min(out$img)) < 0 ) {
        out$img = out$img - min(min(out$img))
    }
    out$img = out$img / max(max(out$img))
    # Store some information: number of points needed and percentage of the original required
    out$nb_pixels_original = dim(im$u)[1] * dim(im$v)[2]
    out$nb_pixels_compressed = length(d_tmp) + dim(u_tmp)[1]*dim(u_tmp)[2] + dim(v_tmp)[1]*dim(v_tmp)[2] 
    out$pct_of_original = out$nb_pixels_compressed / out$nb_pixels_original * 100
    # Return the result
    return(out)
}
@


\begin{frame}[fragile]\frametitle{Recreating the image}
We can now recreate the image using the function \code{compress\_image}
\vfill
<<plot-image-svd-n2,crop=TRUE>>=
new_image = my_image_g
M.svd = svd(M)
M_tmp = compress_image(M.svd, 2)
new_image@grey = M_tmp$img
plot(new_image)
@
\end{frame}

\begin{frame}\frametitle{Using $n=2$ singular values}
\begin{center}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-original", "png")}}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-n2", "png")}}
\end{center}
\vfill
Uses \Sexpr{round(M_tmp$pct_of_original, 2)}\% of the original information
\end{frame}

<<plot-image-svd-n5,echo=FALSE,crop=TRUE>>=
M_tmp = compress_image(M.svd, 5)
new_image@grey = M_tmp$img
plot(new_image)
@

\begin{frame}\frametitle{Using $n=5$ singular values}
\begin{center}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-original", "png")}}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-n5", "png")}}
\end{center}
\vfill
Uses \Sexpr{round(M_tmp$pct_of_original, 2)}\% of the original information
\end{frame}


<<plot-image-svd-n10,echo=FALSE,crop=TRUE>>=
M_tmp = compress_image(M.svd, 10)
new_image@grey = M_tmp$img
plot(new_image)
@

\begin{frame}\frametitle{Using $n=10$ singular values}
\begin{center}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-original", "png")}}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-n10", "png")}}
\end{center}
\vfill
Uses \Sexpr{round(M_tmp$pct_of_original, 2)}\% of the original information
\end{frame}



<<plot-image-svd-n20,echo=FALSE,crop=TRUE>>=
M_tmp = compress_image(M.svd, 20)
new_image@grey = M_tmp$img
plot(new_image)
@

\begin{frame}\frametitle{Using $n=20$ singular values}
\begin{center}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-original", "png")}}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-n20", "png")}}
\end{center}
\vfill
Uses \Sexpr{round(M_tmp$pct_of_original, 2)}\% of the original information
\end{frame}



<<plot-image-svd-n50,echo=FALSE,crop=TRUE>>=
M_tmp = compress_image(M.svd, 50)
new_image@grey = M_tmp$img
plot(new_image)
@

\begin{frame}\frametitle{Using $n=50$ singular values}
\begin{center}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-original", "png")}}
\includegraphics[width=0.45\textwidth]{\Sexpr{knitr::fig_chunk("plot-image-svd-n50", "png")}}
\end{center}
\vfill
Uses \Sexpr{round(M_tmp$pct_of_original, 2)}\% of the original information
\end{frame}





% Save counters for next file

% Save theorem count for next file
\end{document}
